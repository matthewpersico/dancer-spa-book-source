# Echo - SPA

We already know how to send a GET request to the web server to retrieve a fixed thing, but we don't know how to send some data to the server.
A very simple application I like to write to see how this works is called echo. It shows a text box and a button. When we press the button
it sends the text we typed in to the server which promptly returns it.

## Echo the code

To make it a bit more fun, instead of sending back the string as we received we are going to return it backwards.

<<[code/echo.psgi](code/echo.psgi)

Just as in the previous examples, here too we have two routes. One serving the root URL at `/` and one serving the API call at
`/api/echo` but this time the API route is declared with the `post` keyword. We'll get there in a minute.
First let's take a look at the application.

We can launch the development server using `plackup`:

```
plackup code/echo.psgi
```

Then we can visit the web page with our browsers. The first page we see looks like this:

![Echo form](images/echo-form.png)

We can type in some text and click on the `Echo` button to get this without reloading the page:

![Echo response](images/echo-response.png)

In the HTML part we have now 3 HTML elements. An `input` element that has an `id` called `txt`.
That's where the use can type in text.

We have a `button` element that also has an id and some text between the opening and closing part.
This is the text that will appear on the button.

Finally we have an empty `div` element that too has an id.

As you might notice when we build Single Page Applications we tend to assign IDs to many HTML elements
and we don't assign name attributes.  The IDs make it easy to address these elements and the name
attributes are fairly useless.

The first `script` tag is the same as we had earlier. It only loads jQuery.
The second `script` tag contains the specific jQuery code. Everything is wrapped in the following code
as all this code should only run after the page was rendered.

```
$().ready(function () {

});
```

The next line locates the element that has the ID `echo` which is our only button, and to the `click` event of that button attaches an
anonymous callback function. As I've explained earlier most or all of the HTML elements have associated events that are generated by
some external action. For example by the user doing something (e.g. hovering over an element or, in this case, clicking on a button).
We can map each event to a function and when the event happens our browser will execute that function.

In this case we attached a function to click event of the button.

```
$('#echo').click(function () {
```

What happens when the user clicks the button?

We access the element that has the ID `txt` and we fetch the value from that element.

```
$('#txt').val()
```

In the first line in the function we print this value to the console of the browser.

Then we use the `$.post()` function of jQuery to send a POST-request to the server.
The first parameter of this function is the URL where we send the request. In our case it is `/api/echo`.

The second parameter is a JavaScript object. Something that looks very similar to a Perl HASH. (except that instead
of fat arrow `=>` we use the colon `:` to separate key and value.
The key is `txt`, the value is what was typed in the input element.

```
{
    txt: $('#txt').val(),
},
```

The third parameter of the `post` request is another anonymous function.
This function will be executed when the response from the server arrives.
The content of the response will be passed as parameter to this function.
If the server provides a well known Content-Type then the content will
be first processed accordingly and the result of this processing will be passed to the function.

In our case, if you look at the second route in the Perl code, you will see that it sets the
content type to `application/json`. This means jQuery will take the content received from the server.
It will assume we received a JSON string and will convert it to a JavaScript object.

Hence in the function we can already use the `data` variable as a JavaScript object and access the 
"result" field.

TBD...


## Testing Echo

<<[code/echo.t](code/echo.t)

